Step-by-Step Implementation

npm install react-oidc-context

2. Setup OIDC Configuration
// src/authConfig.js
export const oidcConfig = {
  authority: "https://your-forgerock-domain/oauth2/realms/root", // Replace
  client_id: "your-client-id",
  redirect_uri: "http://localhost:3000/callback",
  response_type: "code",
  scope: "openid profile email",
  post_logout_redirect_uri: "http://localhost:3000/",
  automaticSilentRenew: true,
};

3. Wrap App with AuthProvider

// src/index.js
import React from "react";
import ReactDOM from "react-dom/client";
import { AuthProvider } from "react-oidc-context";
import { oidcConfig } from "./authConfig";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")).render(
  <AuthProvider {...oidcConfig}>
    <App />
  </AuthProvider>
);

4. App Routing and Components

// src/App.js
import React from "react";
import { useAuth } from "react-oidc-context";
import Dashboard from "./Dashboard";

const App = () => {
  const auth = useAuth();

  if (auth.isLoading) return <p>Loading...</p>;
  if (auth.error) return <p>Error: {auth.error.message}</p>;

  if (!auth.isAuthenticated) {
    return <button onClick={() => auth.signinRedirect()}>Login</button>;
  }

  return <Dashboard />;
};

export default App;

5. Dashboard + Token Parsing + Auto-Refresh

// src/Dashboard.js
import React, { useEffect } from "react";
import { useAuth } from "react-oidc-context";

const Dashboard = () => {
  const auth = useAuth();

  useEffect(() => {
    const accessToken = auth.user?.access_token;
    const idToken = auth.user?.id_token;
    console.log("Access Token:", accessToken);
    console.log("ID Token:", idToken);
  }, [auth.user]);

  useEffect(() => {
    let timeout;
    let lastActive = Date.now();

    const checkInactivity = () => {
      const now = Date.now();
      const diff = now - lastActive;
      const maxIdle = 5 * 60 * 1000; // 5 mins

      if (diff > maxIdle) {
        auth.signoutRedirect();
      }
    };

    const resetTimer = () => {
      lastActive = Date.now();
    };

    document.addEventListener("mousemove", resetTimer);
    document.addEventListener("keypress", resetTimer);

    timeout = setInterval(() => {
      checkInactivity();
      auth.signinSilent(); // silent token refresh
    }, 60 * 1000); // every 1 minute

    return () => {
      clearInterval(timeout);
      document.removeEventListener("mousemove", resetTimer);
      document.removeEventListener("keypress", resetTimer);
    };
  }, [auth]);

  return (
    <div>
      <h2>Welcome to Dashboard</h2>
      <button onClick={() => auth.signoutRedirect()}>Logout</button>
    </div>
  );
};

export default Dashboard;



spring security vlass:
package com.example.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // Disable CORS and CSRF
            .cors(cors -> cors.disable())
            .csrf(csrf -> csrf.disable())

            // Stateless session
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

            // Disable default login/logout
            .formLogin(form -> form.disable())
            .httpBasic(basic -> basic.disable())

            // Authorize requests
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/vendors/**").authenticated()
                .anyRequest().denyAll()
            )

            // Resource server config for JWT
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(Customizer.withDefaults())
            );

        return http.build();
    }
}

axisozInstance:
// src/services/axiosInstance.js
import axios from "axios";

let getAccessToken = null;

// Axios instance
const axiosInstance = axios.create();

// Request interceptor
axiosInstance.interceptors.request.use(
  async (config) => {
    if (getAccessToken) {
      const token = await getAccessToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Function to inject access token resolver
export const setAuthTokenGetter = (getterFn) => {
  getAccessToken = getterFn;
};

export default axiosInstance;

how to use it:
// src/App.jsx
import React from "react";
import { useAuth } from "react-oidc-context";
import { setAuthTokenGetter } from "./services/axiosInstance"; // adjust path as needed

const App = () => {
  const auth = useAuth();

  React.useEffect(() => {
    setAuthTokenGetter(() => auth.user?.access_token);
  }, [auth]);

  return (
    // your routes or layout here
  );
};

export default App;

inside api.jsx
import axios from "./axiosInstance"; // adjusted import

==================================================== 09-May-2025 ====================================================

// src/services/authService.js
import { useAuth } from "react-oidc-context";

export const useAuthService = () => {
  const {
    isAuthenticated,
    isLoading,
    user,
    signoutRedirect,
    signinRedirect,
    error
  } = useAuth();

  const getAccessToken = () => user?.access_token || null;
  const getUsername = () => user?.profile?.preferred_username || "Unknown";

  const isTokenExpired = () => {
    if (!user) return true;
    return Date.now() >= user.expires_at * 1000;
  };

  return {
    isAuthenticated,
    isLoading,
    error,
    user,
    getAccessToken,
    getUsername,
    isTokenExpired,
    signoutRedirect,
    signinRedirect,
  };
};


In Header.jsx:

import { useAuthService } from "../services/authService";

const Header = () => {
  const { getUsername, signoutRedirect } = useAuthService();

  return (
    <header className="bg-dark text-white p-2 d-flex justify-content-between align-items-center">
      <h4>Vendor Management System</h4>
      <h4>Welcome, {getUsername()}</h4>
      <button className="btn btn-secondary btn-sm" onClick={() => signoutRedirect()}>
        Logout
      </button>
    </header>
  );
};


Use It in a Service: vendorService.js

import { useApi } from "../api";

export const useVendorService = () => {
  const api = useApi();

  const getVendors = () => api.get("/vendors");
  const saveVendor = (vendor) => api.post("/vendors", vendor);
  const updateVendor = (vendor) => api.put(`/vendors/${vendor.id}`, vendor);
  const deleteVendor = (vendorId) => api.delete(`/vendors/${vendorId}`);

  return {
    getVendors,
    saveVendor,
    updateVendor,
    deleteVendor
  };
};




 In App.jsx or Layout.jsx: Handle Expired Tokens
 
 import { useEffect } from "react";
import { useAuthService } from "./services/authService";

const App = () => {
  const { isTokenExpired, signoutRedirect } = useAuthService();

  useEffect(() => {
    if (isTokenExpired()) {
      signoutRedirect(); // Redirect to ForgeRock login
    }
  }, []);
};


==================== using interceptor ===========

// services/apiClient.js
import axios from "axios";
import { useAuthService } from "./authService";

// Create Axios instance
export const useApiClient = () => {
  const { getAccessToken } = useAuthService();

  const client = axios.create({
    baseURL: import.meta.env.VITE_BACKEND_URL || "http://localhost:8080/api"
  });

  // Attach access token to headers
  client.interceptors.request.use(
    (config) => {
      const token = getAccessToken();
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    },
    (error) => Promise.reject(error)
  );

  return client;
};

vendorApi.js â€“ Vendor-specific functions
// services/vendorApi.js
import { useApiClient } from "./apiClient";

export const useVendorApi = () => {
  const api = useApiClient();

  const getVendors = async () => {
    try {
      const response = await api.get("/vendors/getVendors");
      return response.data;
    } catch (err) {
      throw new Error("Failed to fetch vendors: " + err.message);
    }
  };

  const saveVendor = async (vendor) => {
    try {
      const response = await api.post("/vendors", vendor);
      return response.data;
    } catch (err) {
      throw new Error("Failed to save vendor: " + err.message);
    }
  };

  return { getVendors, saveVendor };
};

4. How to Use It (e.g., in VendorContext)

import { useVendorApi } from "../services/vendorApi";

export const VendorProvider = ({ children }) => {
  const { getVendors } = useVendorApi();

  const fetchVendors = async () => {
    const data = await getVendors();
    setVendors(data);
    setIsLoaded(true);
  };

  ...
};





